C++ only guarantees that integer variables will have a minimum size but they could be larger
depending on the target system.

int has a minimum size of 16 - bits but it's typically 32 bits on modern architectures
In C++11 fixed-width integers were introduced so that integer types would be 
gauranteed the same size on any architecture.

std::int8_t	    1 byte signed	 -128 to 127	                  Treated like a signed char on many systems. See note below.
std::uint8_t	1 byte unsigned	 0 to 255	                      Treated like an unsigned char on many systems. See note below.
std::int16_t	2 byte signed	 -32,768 to 32,767	
std::uint16_t	2 byte unsigned	 0 to 65,535	
std::int32_t	4 byte signed	 -2,147,483,648 to 2,147,483,647	
std::uint32_t	4 byte unsigned	 0 to 4,294,967,295	
std::int64_t	8 byte signed	 -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807	
std::uint64_t	8 byte unsigned	 0 to 18,446,744,073,709,551,615

Downsides of Fixed-width integers
- Fixed-width integers are not guarenteed to be defined on all architectures
- It may be slower than a wider type on some architectures


Best practice
Avoid the fast and least integral types because they may exhibit different behaviors on architectures
where they resolve to different sizes.
